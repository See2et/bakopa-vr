## Project Overview
このプロジェクトは、分散型Social-VR「SuteraVR」と呼称されるものです。従来のSocial-VRが特にインフラ／通信コストに苛まれていることに課題意識を持ち、それをFederationとP2Pによる二重分散により解決することを志向しています。

詳細は`docs/product.md`と`docs/architecture.md`を参照して下さい。

## Coding Rules
### Do Test-Driven Development & Spec-Driven Development
和田卓人（t-wada）氏が提唱するテスト駆動開発（TDD）と仕様駆動開発（SDD）に則って開発を進めて下さい。

- **テストが開発を駆動する:** すべてのプロダクションコードは、失敗するテストをパスさせるためだけに書かれます。テストは後付けの作業ではありません。それ自身が仕様書であり、設計の駆動役です。
- **リファクタリングへの自信:** 包括的なテストスイートは我々のセーフティネットです。これにより、私たちは恐れることなく継続的にコードベースのリファクタリングと改善を行えます。
- **テスト容易性は良い設計に等しい:** コードがテストしにくい場合、それは悪い設計の兆候です。エージェントは、テスト容易性の高いコード作成を最優先しなければなりません。それは自然と、疎結合で凝集度の高いアーキテクチャにつながります。

Coding Agentは、いかに小さな変更であっても、必ずこの反復的なサイクルに従わなければなりません。コードを生成する際は、現在どのフェーズにいるのかを明示してください。

また、**仕様が不明瞭なときは勝手に「良さそうな実装」をしない**で下さい。適宜ユーザーに仕様書の更新提案や質疑応答を行って下さい。

#### フェーズ0: スペック（Spec） - 仕様を明文化する

- **目的:** これから実装する振る舞いを、自然言語とテスト観点の両方で明確に定義する。
- **行動:** `docs/specs/TEMPLATE.md`を参考に、`docs/specs/YYYYMMDD-{SpecName}.md`に仕様書を保存する。
- **条件:**
  - 仕様が十分に明確でない場合、Coding Agent は**勝手な解釈で実装に進んではならない**。
  - 少なくとも 1 つ以上の具体的なハッピーケースと、代表的な失敗ケースを言語化してからフェーズ1に進むこと。

#### フェーズ1: レッド - 失敗するテストを書く

- **目的:** これから何を達成するのかを、テストとして**ひとつに絞って**明確に定義する。
- **行動:**
  - フェーズ0で定義した仕様のうち、単一の機能・振る舞いに対応する**具体的で失敗するテストを 1 つ**作成する。
  - テストは、仕様の一部を正確に反映した「実行可能な例」となっていること。
- **条件:**
  - 対応する実装がまだ存在しない、または未完であるため、このテストは必ず失敗（**レッド**）しなければならない。
  - 一度に複数の振る舞いをテストしようとしないこと。失敗理由が明確に特定できる粒度に分割する。

#### フェーズ2: グリーン - テストをパスさせる

- **目的:** テストで示された要件を、最小限の実装で満たす。
- **行動:**
  - フェーズ1で作成した失敗テストをパスさせるために必要な、**最小限のコード**だけを記述する。
  - 仕様やテストで明示されていない振る舞いを勝手に追加しない。
- **条件:**
  - この段階で余分な機能を追加しないこと（YAGNI原則）。  
  - コードの美しさや汎用性は追求せず、ただテストをパス（**グリーン**）させることだけを考える。
  - すべての既存テストがグリーンであることを確認する（新テストだけでなく、回帰を許さない）。

#### フェーズ3: リファクタリング - 設計とスペックを改善する

- **目的:** テストが通っている状態を維持しながら、コードとテスト、および仕様表現の品質を向上させる。
- **行動:**
  - テストが成功しているという安全な状態で、コードの内部構造を改善する。これには以下の作業が含まれるが、これに限定されない。
    - 重複の排除（DRY原則）
    - 命名の明確化（ドメインに即した名前への変更）
    - 複雑なロジックの単純化・分割
    - 副作用の分離、関心の分離（SoC）
  - テストコードおよびスペック表現もリファクタリング対象とする。
    - テスト名やテストケースの説明を、仕様の意図がより伝わる形にする。
    - 過度に実装に引きずられたテストを、より振る舞いベースのテストに書き換える。
- **条件:**
  - リファクタリングの全プロセスを通じて、すべてのテストは**常にグリーン**でなければならない。
  - 仕様変更を伴わないリファクタリングでは、テストの期待値（振る舞い）は変えてはならない。
  - 仕様そのものを変更する場合は、**先にスペックとテストの期待値を更新し、その後で実装を調整する**。

#### フェーズ4: コミット - 進捗を保存する

- **目的:**  
  正常に動作する小さな機能単位を、安全なバージョンとして記録する。
- **行動:**
  - リファクタリングが完了し、全テストがグリーンであることを最終確認する。
  - `git status` で変更範囲を確認し、意図しない変更が含まれていないことを確認する。
  - `git add .` などで変更をステージングする。
  - コミットメッセージには、**追加・変更された仕様（Spec）と、それに対応するテスト／実装の要約**を簡潔に含める。
- **条件:**
  - このサイクルで実装された変更が、一つの意味のあるまとまりとして完結していること。
    - 例: 「ユーザー登録時のメールアドレス重複チェックを追加」など
  - コミットに含まれる変更は、すべてテストでカバーされていること（新機能・バグ修正ともに例外なし）。
  - スペック（ドキュメント／コメント／Issue のチェックリストなど）がコードと乖離していないこと。


### Logging/Trace
#### 使用クレートと前提

- ログ／トレースはすべて `tracing` 経由で出すこと。`println!` や標準 `log` マクロを新しく追加しない。
- バイナリクレート側でのみグローバル Subscriber を初期化する。ライブラリコードからは **絶対に Subscriber を初期化しない**。
- 既存コードが `log` を使っている場合は、`tracing-subscriber` の `LogTracer` 等でブリッジする（`log` 呼び出しを消さずに `tracing` に流す）。

#### ログ設計の基本方針

1. **構造化ログを前提とする**
   - メッセージを文字列連結せず、できるだけフィールドとして持たせる。
   - 例: `info!(order_id = order.id, user_id = user.id, "order created");`

2. **span を単位にフローを追えるようにする**
   - 「リクエスト単位」「ジョブ単位」「大きな処理単位」で `span` を張る。
   - HTTP ハンドラ、キューコンシューマ、長時間処理の入口には原則 `#[instrument]` を付与する。
   - 子処理は親 span の中で `info!` などを打ち、どのリクエスト由来かが辿れるようにする。

3. **レベルの使い分け**
   - `error!`… ユーザー影響のある失敗。アラート対象候補。
   - `warn!`… 明確なバグではないが怪しい状態／フェイルオーバー発生。
   - `info!`… ビジネス的に意味のあるイベント（作成・状態遷移など）。
   - `debug!`… デバッグに有用だが通常は不要な詳細。
   - `trace!`… ループ内部など高頻度・超詳細。原則、慎重に使用。

4. **本番向けフォーマット**
   - 本番環境では JSON ログ（機械可読）を前提とする。
   - ログフォーマットやフィルタレベルは環境変数（例: `RUST_LOG`, `LOG_FORMAT`）で切り替え可能にする。

5. **セキュリティ／プライバシー**
   - パスワード、秘密鍵、トークン、クレジットカード情報などの機密情報は絶対にログに出さない。
   - ユーザー識別には内部 ID を使い、生データ（メールアドレス等）は必要な場合のみフィールドとして記録する。

### Error Handling

このプロジェクトでは、エラー処理の基盤として **`anyhow`** と **`thiserror`** を使用する。  

#### 前提となる役割分担

- **`anyhow`**
  - `anyhow::Error` と `anyhow::Result<T>` による「型消去された汎用エラー型」。
  - **アプリケーションコード**での「簡易なエラー統合・伝搬・コンテキスト付与」に用いる。
- **`thiserror`**
  - `#[derive(Error)]` で `std::error::Error` 実装を自動生成するためのクレート。
  - **ライブラリ／ドメイン層**での「型付きエラー定義」に用いる。


- **ライブラリ／ドメイン層** → `thiserror` で意味のある Error 型を定義
- **アプリケーション境界（`main` など）** → 複数の Error を `anyhow` でまとめて扱う

#### アプリケーション層（binary crate）でのルール — anyhow

1. **戻り値は `anyhow::Result<T>` を使うのは「最上位だけ」**
   - `main` や CLI ハンドラ、HTTP サーバのエントリポイントなど、  
     「最終的にログを出して終了／レスポンスに変換する層」に限定して `anyhow::Result<()>` を使う。
   - ドメインロジックにまで `anyhow::Result` を広げない。

   ```rust
   use anyhow::Result;

   fn main() -> Result<()> {
       app::run()?;
       Ok(())
   }
   ```


2. **`.context()` / `.with_context()` でエラーに文脈を必ず付ける**

   * 「どの操作中に失敗したのか」がわかるメッセージを付ける。

   ```rust
   use anyhow::{Context, Result};

   fn load_config(path: &str) -> Result<String> {
       std::fs::read_to_string(path)
           .with_context(|| format!("failed to read config from {path}"))
   }
   ```

3. **「ハンドルできない／ハンドルしない」境界でのみ anyhow に集約する**

   * HTTP レイヤや CLI レイヤで「ログを出す」「ユーザー向けメッセージに変換する」直前で、
     下位の `thiserror` ベースのエラーを `anyhow::Error` に吸わせるのは OK。
   * それより下の層では **独自 Error 型のまま** 保つ。

4. **`unwrap` / `expect` の禁止（初期化コードなど例外的ケースを除く）**

   * ランタイムで発生しうる失敗はすべて `Result` / `Option` として扱い、`?` と `anyhow` / `thiserror` で処理する。

#### ライブラリ／ドメイン層でのルール — thiserror

1. **Public API では `anyhow` を返さず、自前の Error 型を定義する**

   * `pub fn ... -> Result<T, Error>` の `Error` は自前の enum / struct。
   * `anyhow::Error` を public API に出すのは禁止。

   ```rust
   use thiserror::Error;

   #[derive(Debug, Error)]
   pub enum RepositoryError {
       #[error("db error: {0}")]
       Db(#[from] sqlx::Error),

       #[error("entity not found: {id}")]
       NotFound { id: String },
   }

   pub type Result<T> = std::result::Result<T, RepositoryError>;
   ```

2. **`#[from]` で外部エラーをラップし、source を保持する**

   * 依存クレートのエラーや IO エラーは、`#[from]` を使って自動変換する。
   * これにより `?` 演算子で自然に伝搬できる。

3. **エラー型は「使う側の判断に必要な粒度」で設計する**

   * 「ユーザー入力ミス」「外部サービスの障害」「内部バグ」など、
     リトライ可否や HTTP ステータス変換などに必要な分類を enum variant として持たせる。

   ```rust
   #[derive(Debug, Error)]
   pub enum DomainError {
       #[error("invalid input: {0}")]
       InvalidInput(String),

       #[error("external service failed: {0}")]
       External(String),

       #[error("unexpected internal error")]
       Internal(#[from] anyhow::Error), // ← ドメイン内だけで包むのはアリ
   }
   ```

4. **Error 型はモジュール／境界ごとに分ける**

   * 1 つの巨大な `Error` enum に何でも詰め込まず、
     「RepositoryError」「DomainError」「ApiError」のように責務ごとに分割する。

### Use Strong Types, Not Primitive Obsession
❌ 全てを`String`,`u64`,`i32`などのプリミティブ型で表現
✅ 必要に応じて`UserID`,`Timeout`,`EmailAddress`などの意味を持った型やenumを定義

**examples**
```diff
- fn send_email(to: String, body: String) { /* ... */ }
+ pub struct EmailAddress(String);
+ pub struct EmailBody(String);
+ 
* fn send_email(to: EmailAddress, body: EmailBody) { /* ... */ }
```

### 単純な抽象 (Simple Abstractions)
- 公開APIでジェネリクス・ネストを深くしない。
    - 例: `Foo<T>` までは許容、`Foo<Bar<Baz<T>>>` のような型をパブリックに出さない。
- 特に「サービスレベル型」では、`Service<Backend<Store>>` のような多段ネスト型を公開しない。
    - 公開型は `Service` など単純な表現とし、内部で構成要素を隠蔽する。

### ラッパー型／スマートポインタ非露出
- 公開APIの引数・戻り値に `Arc<T>` / `Rc<T>` / `Box<T>` / `RefCell<T>` 等を直接出ささない。
- 原則として `T` / `&T` / `&mut T` を使わせる。
- 共有や所有戦略はライブラリ内部に閉じ込める。
